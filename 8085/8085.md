<br>
<h1 align="center"> INTRODUCTION TO 8085-MICROPROCESSOR </h1>
<h2> :sparkle: <em>8085 Architecture</em> </h2>

<p align="center">
<img src="/8085/8085-Microprocessor.png" style="height: 500px; width:800px;"/>
</p>

<br>
<h3> Arithmetic and Logic Unit (ALU)</h3>
  
- It is a circuit that performs arithmetic and logical operations on data, including addition, subtraction, comparison, shifting, and logical operations. It works with the Accumulator and two temporary registers (W and Z) to hold data temporarily during operations.

<br>
<h3>Registers</h3>

- Registers are small memory elements within the CPU that provide temporary storage for data, instructions, and addresses during execution. They are directly connected to the processor for quick access without delays. The number of registers varies between processors. In the Intel 8085, there are 8 registers, including the Accumulator (A register), the flag register and 6 general-purpose registers (B, C, D, E, H, and L), arranged as a register array. Each register can be used as an 8-bit register to store 8-bit data or paired with another register to store 16-bit data. The HL register pair, known as the Memory Address Register (MAR) or Memory Pointer, is used to store memory addresses.

<p align="center">
<img src="/8085/register1.png" style="height: 400px; width:700px;"/>
</p>

<br>
<p align="center">
<img src="/8085/register2.png" style="height: 300px; width:500px;"/>
</p>

>M register is a memory location to be accessed, whose address is given in the HL register pair

<br>
<h3>Accumulator (A)</h3>

- The Accumulator (A) is an 8-bit register in the 8085 microprocessor used for arithmetic and logical operations. It is the primary register for performing arithmetic operations and storing intermediate results/ result of an operation.

<br>
<h3>Flags / Status Register</h3>

- Five bits or flip-flops of status register are labelled as S (Sign), Z (Zero), AC (Auxiliary Carry), P (Parity) and CY (Carry), are known as status flag. The role of this register is to exhibit the status of result generated by the ALU, by recording different logical conditions. 

<br>
<p align="center">
<img src="/8085/statusregister.png" style="height: 300px; width:500px;"/>
</p>

1. **Sign Flag (S)**: This flag is set if the result of an arithmetic or logical operation has a negative value. The Sign Flag is affected by the most significant bit (MSB) of the result. If the MSB is 1, indicating a negative result in the signed 2's complement representation, the Sign Flag is set to 1.

2. **Zero Flag (Z)**: This flag is set if the result of an operation is zero. When all the bits of the result are 0, the Zero Flag is set to 1, indicating that the result is zero.

3. **Auxiliary Carry Flag (AC)**: This flag is used in BCD (Binary Coded Decimal) arithmetic operations. It is set when a carry-out occurs from the low nibble (4 bits) to the high nibble during arithmetic operations. It is helpful for handling BCD arithmetic and decimal adjustments.

4. **Parity Flag (P)**: The Parity Flag is set if the result of an operation has even parity, which means it contains an even number of 1's in its binary representation. If the result has even parity, the Parity Flag is set to 1; otherwise, it is set to 0.

5. **Carry Flag (CY)**: This flag is set when there is a carry-out from the most significant bit during arithmetic operations. In an addition operation, if the sum exceeds the capacity of the 8-bit register (255 in decimal or 1111 1111 in binary), a carry-out occurs, and the Carry Flag is set to 1. Similarly, in subtraction operations, the Carry Flag is set if a borrow is required.

>These status flags are crucial for conditional branching instructions (conditional jumps) and to determine the outcome of various conditional operations. Program control and decision-making rely on these flags, allowing the microprocessor to execute different instructions based on the status of the previous operation.

<br>
<h3>Stack Pointer (SP)</h3>

The Stack Pointer (SP) is a 16-bit register in the 8085 microprocessor that plays a crucial role in managing stack operations. The stack is a region of memory used to store data temporarily, especially during subroutine calls and interrupts. The Stack Pointer keeps track of the top of the stack, which is the memory location where the last value was pushed onto the stack.

**Stack Operations**:
- The stack operates in a Last-In-First-Out (LIFO) manner, meaning that the last value pushed onto the stack is the first one to be popped off. The SP points to the memory location where the next value will be pushed.

**Stack Push Operation**:
- When data needs to be saved on the stack, it is pushed onto the memory location pointed by the Stack Pointer (SP).
- After the data is pushed, the SP is decremented by 1 (for an 8-bit stack) or 2 (for a 16-bit stack) to point to the next available memory location on the stack.

**Stack Pop Operation**:
- When data is required to be retrieved from the stack, the SP is first incremented by 1 (or 2 for a 16-bit stack) to point to the memory location where the data was last pushed.
- The data is then popped from that location, and the SP is updated to point to the next available data on the stack.

**Stack Usage**:
- The stack is used for various purposes, including storing return addresses during subroutine calls, preserving register values in interrupt service routines, and saving the context of the program during context switches for multitasking systems.

**Interrupt Handling**:
- When an interrupt occurs, the 8085 microprocessor automatically saves the current Program Counter (PC) value on the stack. This allows the microprocessor to return to the interrupted program once the interrupt service routine is completed.

**Stack Size**:
- The stack size depends on the memory available in the system. In the 8085 microprocessor, the stack size can go up to 64KB (with a 16-bit SP), provided that the memory addresses are properly managed.

The Stack Pointer is a critical component of the 8085 microprocessor's architecture, enabling efficient memory management during program execution, subroutine calls, and interrupt handling.
